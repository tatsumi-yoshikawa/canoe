<!-- <h1>detail.html</h1>
<h2>ChatGPT ã«ã‚ˆã‚‹</h2> -->

<!-- 
<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ONE-FILE: ãƒŸãƒ‹ã‚·ãƒ¼ã‚±ãƒ³ã‚µãƒ¼ + éŸ³ã«åå¿œã™ã‚‹ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ©ã‚¤ã‚¶</title>
  <style>
    :root{
      --bg0:#070A12;
      --bg1:#0B1630;
      --panel: rgba(255,255,255,.06);
      --panel2: rgba(255,255,255,.10);
      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.68);
      --gridOff: rgba(255,255,255,.08);
      --gridOn: rgba(80, 220, 255, .92);
      --gridOn2: rgba(255, 120, 220, .92);
      --accent: rgba(120, 255, 160, .92);
      --danger: rgba(255, 120, 120, .92);
      --shadow: 0 14px 40px rgba(0,0,0,.45);
      --radius: 16px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", "Hiragino Kaku Gothic ProN", "Yu Gothic", "Meiryo", sans-serif;
    }
    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      color:var(--text);
      font-family:var(--sans);
      background: radial-gradient(1200px 800px at 70% 10%, #14315f 0%, transparent 55%),
                  radial-gradient(1000px 800px at 10% 20%, #2a144f 0%, transparent 55%),
                  linear-gradient(180deg, var(--bg1), var(--bg0));
      overflow:hidden;
    }

    /* èƒŒæ™¯ã‚­ãƒ£ãƒ³ãƒã‚¹ */
    #viz{
      position:fixed;
      inset:0;
      width:100%;
      height:100%;
      display:block;
    }

    /* UI */
    .wrap{
      position:relative;
      height:100%;
      display:grid;
      grid-template-rows: auto 1fr auto;
      gap:14px;
      padding:16px;
      pointer-events:none; /* ãƒ‘ãƒãƒ«ã ã‘ã‚¯ãƒªãƒƒã‚¯ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ */
    }
    header, main, footer { pointer-events:none; }

    header{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:12px;
    }
    .title{
      pointer-events:auto;
      background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.04));
      border:1px solid rgba(255,255,255,.12);
      box-shadow: var(--shadow);
      border-radius: var(--radius);
      padding:12px 14px;
      backdrop-filter: blur(10px);
      max-width: 820px;
    }
    .title h1{
      margin:0;
      font-size: 14px;
      letter-spacing:.02em;
      font-weight: 700;
      display:flex;
      align-items:center;
      gap:10px;
    }
    .pill{
      font-family:var(--mono);
      font-size:12px;
      padding:2px 8px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.18);
      color: rgba(255,255,255,.85);
      background: rgba(255,255,255,.06);
    }
    .title p{
      margin:8px 0 0 0;
      font-size:12px;
      color:var(--muted);
      line-height:1.55;
    }
    .kbd{
      font-family: var(--mono);
      font-size: 11px;
      padding: 1px 6px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,.18);
      background: rgba(0,0,0,.22);
      color: rgba(255,255,255,.85);
      display:inline-block;
      transform: translateY(-1px);
    }

    .panel{
      pointer-events:auto;
      background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.04));
      border:1px solid rgba(255,255,255,.12);
      box-shadow: var(--shadow);
      border-radius: var(--radius);
      backdrop-filter: blur(10px);
    }
    .controls{
      display:flex;
      gap:10px;
      align-items:center;
      padding:12px;
      flex-wrap: wrap;
    }
    button{
      appearance:none;
      border:1px solid rgba(255,255,255,.16);
      background: rgba(255,255,255,.06);
      color:var(--text);
      border-radius: 12px;
      padding: 10px 12px;
      cursor:pointer;
      font-weight: 650;
      letter-spacing:.01em;
      transition: transform .08s ease, background .15s ease, border-color .15s ease;
      user-select:none;
    }
    button:hover{ background: rgba(255,255,255,.10); border-color: rgba(255,255,255,.22); }
    button:active{ transform: translateY(1px); }
    button.primary{ border-color: rgba(120,255,160,.35); background: rgba(120,255,160,.12); }
    button.danger{ border-color: rgba(255,120,120,.35); background: rgba(255,120,120,.12); }
    button.ghost{ background: rgba(255,255,255,.03); }

    .row{
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
    }
    .label{
      font-size:12px;
      color:var(--muted);
      min-width: 70px;
    }
    input[type="range"]{
      width: 190px;
      accent-color: rgba(120,255,160,.92);
    }
    .value{
      font-family: var(--mono);
      font-size: 12px;
      color: rgba(255,255,255,.85);
      padding: 2px 8px;
      border-radius: 999px;
      background: rgba(0,0,0,.20);
      border: 1px solid rgba(255,255,255,.12);
    }

    main{
      display:grid;
      grid-template-columns: 1fr 320px;
      gap:14px;
      min-height: 0;
    }
    @media (max-width: 980px){
      main{ grid-template-columns: 1fr; }
    }

    .seq{
      padding:12px;
      display:flex;
      flex-direction:column;
      min-height:0;
    }
    .seqTop{
      display:flex;
      align-items:baseline;
      justify-content:space-between;
      gap:10px;
      padding: 2px 2px 10px 2px;
      border-bottom: 1px solid rgba(255,255,255,.10);
      margin-bottom: 10px;
    }
    .seqTop .hint{
      font-size:12px;
      color: var(--muted);
      line-height:1.4;
    }
    .status{
      font-family: var(--mono);
      font-size: 12px;
      color: rgba(255,255,255,.80);
      padding: 3px 8px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.05);
      white-space:nowrap;
    }

    .gridWrap{
      overflow:auto;
      border-radius: 12px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
    }
    .grid{
      display:grid;
      grid-template-columns: 86px repeat(16, 34px);
      gap:6px;
      padding:10px;
      min-width: max-content;
    }
    .hdr{
      position:sticky;
      top:0;
      z-index:2;
      background: rgba(0,0,0,.40);
      backdrop-filter: blur(10px);
      border-radius: 10px;
    }
    .cell, .stepLabel, .pitchLabel{
      height: 28px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,.10);
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:12px;
      user-select:none;
    }
    .pitchLabel{
      justify-content:flex-start;
      padding:0 10px;
      gap:8px;
      font-family: var(--mono);
      color: rgba(255,255,255,.78);
      background: rgba(255,255,255,.04);
    }
    .pitchDot{
      width:10px; height:10px; border-radius:999px;
      background: rgba(80, 220, 255, .8);
      box-shadow: 0 0 0 3px rgba(80,220,255,.10);
      flex: 0 0 auto;
    }
    .pitchDot.alt{
      background: rgba(255, 120, 220, .75);
      box-shadow: 0 0 0 3px rgba(255,120,220,.10);
    }

    .stepLabel{
      font-family: var(--mono);
      color: rgba(255,255,255,.65);
      background: rgba(255,255,255,.03);
    }
    .cell{
      cursor:pointer;
      background: rgba(255,255,255,.03);
      transition: background .12s ease, border-color .12s ease, transform .08s ease;
    }
    .cell:hover{ background: rgba(255,255,255,.06); }
    .cell:active{ transform: translateY(1px); }
    .cell.on{
      background: linear-gradient(180deg, rgba(80,220,255,.32), rgba(80,220,255,.10));
      border-color: rgba(80,220,255,.42);
      box-shadow: 0 0 0 3px rgba(80,220,255,.08) inset;
    }
    .cell.on.alt{
      background: linear-gradient(180deg, rgba(255,120,220,.30), rgba(255,120,220,.10));
      border-color: rgba(255,120,220,.42);
      box-shadow: 0 0 0 3px rgba(255,120,220,.08) inset;
    }
    .cell.playhead{
      outline: 2px solid rgba(120,255,160,.60);
      outline-offset: 1px;
    }

    .side{
      padding:12px;
      display:flex;
      flex-direction:column;
      gap:12px;
      min-height:0;
    }
    .card{
      padding:12px;
      border-radius: 14px;
      background: rgba(0,0,0,.18);
      border:1px solid rgba(255,255,255,.10);
    }
    .card h2{
      margin:0 0 8px 0;
      font-size: 13px;
      letter-spacing:.02em;
    }
    .card p{
      margin:0;
      font-size:12px;
      color:var(--muted);
      line-height:1.55;
    }
    .tiny{
      margin-top:8px;
      font-family: var(--mono);
      font-size: 11px;
      color: rgba(255,255,255,.65);
      white-space: pre-wrap;
      word-break: break-word;
      padding: 8px;
      border-radius: 12px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
    }
    .toast{
      position:fixed;
      left:50%;
      bottom:18px;
      transform: translateX(-50%);
      pointer-events:none;
      padding: 10px 12px;
      border-radius: 999px;
      background: rgba(0,0,0,.55);
      border: 1px solid rgba(255,255,255,.14);
      color: rgba(255,255,255,.90);
      font-size: 12px;
      opacity: 0;
      transition: opacity .18s ease, transform .18s ease;
      backdrop-filter: blur(10px);
    }
    .toast.show{
      opacity:1;
      transform: translateX(-50%) translateY(-2px);
    }

    footer{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
    }
    .footNote{
      pointer-events:auto;
      padding:10px 12px;
      border-radius: var(--radius);
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.04);
      backdrop-filter: blur(10px);
      font-size:12px;
      color: var(--muted);
      max-width: 900px;
    }
    a{ color: rgba(120,255,160,.92); text-decoration: none; }
    a:hover{ text-decoration: underline; }

    /* ãƒ¢ãƒã‚¤ãƒ«ã§æ“ä½œã—ã‚„ã™ã */
    @media (pointer: coarse){
      .grid{ grid-template-columns: 94px repeat(16, 40px); }
      .cell, .stepLabel, .pitchLabel{ height: 34px; border-radius: 12px; }
      button{ padding: 11px 13px; }
    }
  </style>
</head>

<body>
<canvas id="viz"></canvas>

<div class="wrap">
  <header>
    <div class="title">
      <h1>
        ONE-FILE ã‚·ãƒ¼ã‚±ãƒ³ã‚µãƒ¼
        <span class="pill">HTML only</span>
        <span class="pill">WebAudio</span>
        <span class="pill">Canvas</span>
        <span class="pill">localStorage</span>
      </h1>
      <p>
        16ã‚¹ãƒ†ãƒƒãƒ—Ã—8éŸ³ã®ã‚¯ãƒªãƒƒã‚¯å¼ã‚·ãƒ¼ã‚±ãƒ³ã‚µãƒ¼ã€‚éŸ³ã«åå¿œã—ã¦èƒŒæ™¯ãŒå‹•ãã¾ã™ã€‚<br/>
        æ“ä½œ: <span class="kbd">Space</span> å†ç”Ÿ/åœæ­¢ / <span class="kbd">R</span> ãƒ©ãƒ³ãƒ€ãƒ  / <span class="kbd">C</span> ã‚¯ãƒªã‚¢ / <span class="kbd">S</span> å…±æœ‰ãƒªãƒ³ã‚¯
      </p>
    </div>

    <div class="panel controls" role="group" aria-label="controls">
      <button id="btnPlay" class="primary">â–¶ å†ç”Ÿ</button>
      <button id="btnRandom" class="ghost">ğŸ² ãƒ©ãƒ³ãƒ€ãƒ </button>
      <button id="btnClear" class="danger">âœ• ã‚¯ãƒªã‚¢</button>

      <div class="row" style="margin-left:6px;">
        <span class="label">Tempo</span>
        <input id="tempo" type="range" min="60" max="180" step="1" value="120" />
        <span id="tempoVal" class="value">120</span>
      </div>

      <div class="row">
        <span class="label">Swing</span>
        <input id="swing" type="range" min="0" max="0.45" step="0.01" value="0.12" />
        <span id="swingVal" class="value">0.12</span>
      </div>

      <div class="row">
        <span class="label">Tone</span>
        <input id="tone" type="range" min="0" max="1" step="0.01" value="0.55" />
        <span id="toneVal" class="value">0.55</span>
      </div>
    </div>
  </header>

  <main>
    <section class="panel seq">
      <div class="seqTop">
        <div class="hint">
          ã‚°ãƒªãƒƒãƒ‰ã‚’ã‚¯ãƒªãƒƒã‚¯ã§ON/OFFã€‚åˆ—ã®æ•°å­—ã¯ã‚¹ãƒ†ãƒƒãƒ—ã€‚è¡Œã¯éŸ³ã®é«˜ã•ï¼ˆä¸ŠãŒé«˜ã„ï¼‰ã€‚<br/>
          å…±æœ‰ãƒªãƒ³ã‚¯ã¯URLã®ãƒãƒƒã‚·ãƒ¥ã«ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’åŸ‹ã‚è¾¼ã¿ã¾ã™ï¼ˆã‚µãƒ¼ãƒä¸è¦ï¼‰ã€‚
        </div>
        <div class="status" id="status">Audio: æœªåˆæœŸåŒ–</div>
      </div>

      <div class="gridWrap">
        <div id="grid" class="grid" aria-label="sequencer grid"></div>
      </div>
    </section>

    <aside class="panel side">
      <div class="card">
        <h2>ãƒ‘ã‚¿ãƒ¼ãƒ³å…±æœ‰</h2>
        <p>ä¸‹ã®ã€Œå…±æœ‰ç”¨ãƒ†ã‚­ã‚¹ãƒˆã€ã‚’ã‚³ãƒ”ãƒ¼ã—ã¦åˆ¥ç«¯æœ«ã§é–‹ãã¨åŒã˜ãƒ‘ã‚¿ãƒ¼ãƒ³ã«ãªã‚Šã¾ã™ã€‚</p>
        <div id="shareText" class="tiny">(ã¾ã ç”Ÿæˆã•ã‚Œã¦ã„ã¾ã›ã‚“)</div>
        <div style="display:flex; gap:10px; margin-top:10px; flex-wrap:wrap;">
          <button id="btnShare" class="ghost">ğŸ”— å…±æœ‰ãƒªãƒ³ã‚¯ã‚’ç”Ÿæˆ</button>
          <button id="btnCopy" class="ghost">ğŸ“‹ ã‚³ãƒ”ãƒ¼</button>
        </div>
      </div>

      <div class="card">
        <h2>ã¡ã‚‡ã„è©¦ä½œãƒã‚¤ãƒ³ãƒˆ</h2>
        <p>
          ãƒ»ãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œã§AudioContextã‚’é–‹å§‹ï¼ˆãƒ–ãƒ©ã‚¦ã‚¶åˆ¶é™å¯¾å¿œï¼‰<br/>
          ãƒ»ãƒ«ãƒƒã‚¯ã‚¢ãƒ˜ãƒƒãƒ‰ã§ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒªãƒ³ã‚°ï¼ˆå®‰å®šå†ç”Ÿï¼‰<br/>
          ãƒ»localStorageã«è‡ªå‹•ä¿å­˜<br/>
          ãƒ»Canvasã§éŸ³ã«åŒæœŸã—ãŸãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«è¡¨ç¤º
        </p>
      </div>

      <div class="card">
        <h2>éŸ³é‡ã®æ³¨æ„</h2>
        <p>æœ€åˆã¯æ§ãˆã‚ã§ã™ãŒã€ç’°å¢ƒã«ã‚ˆã£ã¦å¤§ããèã“ãˆã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚å¿…è¦ãªã‚‰OSå´ã§èª¿æ•´ã—ã¦ãã ã•ã„ã€‚</p>
      </div>
    </aside>
  </main>

  <footer>
    <div class="footNote">
      1ãƒ•ã‚¡ã‚¤ãƒ«ã§å®Œçµã€‚å¤–éƒ¨ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãªã—ã€‚ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ã§ã‚‚å‹•ãã¾ã™ã€‚<br/>
      ãã®ã¾ã¾ä¿å­˜ã—ã¦é–‹ãã ã‘ã§OKï¼ˆä¾‹: <span class="kbd">sequencer.html</span>ï¼‰ã€‚
    </div>
    <div class="footNote" style="text-align:right;">
      ãƒ’ãƒ³ãƒˆ: ãƒ‘ã‚¿ãƒ¼ãƒ³ä½œã‚Šã«è©°ã¾ã£ãŸã‚‰ <span class="kbd">R</span> â†’ æ°—ã«å…¥ã£ãŸã‚‰å°‘ã—ãšã¤æ•´ãˆã‚‹
    </div>
  </footer>
</div>

<div id="toast" class="toast" aria-live="polite"></div>

<script>
(() => {
  "use strict";

  // ====== ä¾¿åˆ©é–¢æ•° ======
  const $ = (sel, el=document) => el.querySelector(sel);
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const lerp = (a, b, t) => a + (b - a) * t;

  function toast(msg){
    const el = $("#toast");
    el.textContent = msg;
    el.classList.add("show");
    clearTimeout(toast._t);
    toast._t = setTimeout(() => el.classList.remove("show"), 1100);
  }

  // ====== ã‚·ãƒ¼ã‚±ãƒ³ã‚µãƒ¼è¨­å®š ======
  const STEPS = 16;
  const ROWS  = 8;

  // 8éŸ³ï¼ˆCãƒ¡ã‚¸ãƒ£ãƒ¼ç³»ã£ã½ã„ä¸¦ã³ï¼‰ã€‚ä¸Šã»ã©é«˜ã„ã€‚
  // A4=440 ã‚’åŸºæº–ã«ã–ã£ãã‚Šã€‚æ­£ç¢ºã•ã‚ˆã‚Šæ°—æŒã¡è‰¯ã•å„ªå…ˆã€‚
  const PITCHES = [
    { name: "C5",  hz: 523.251 },
    { name: "B4",  hz: 493.883 },
    { name: "A4",  hz: 440.000 },
    { name: "G4",  hz: 391.995 },
    { name: "E4",  hz: 329.628 },
    { name: "D4",  hz: 293.665 },
    { name: "C4",  hz: 261.626 },
    { name: "A3",  hz: 220.000 },
  ];

  // ã‚°ãƒªãƒƒãƒ‰çŠ¶æ…‹ (ROWS x STEPS)
  let grid = Array.from({length: ROWS}, () => Array.from({length: STEPS}, () => false));

  // UI state
  let tempo = 120;
  let swing = 0.12; // 0..0.45
  let tone  = 0.55; // 0..1  (ãƒ•ã‚£ãƒ«ã‚¿/å€éŸ³æ„Ÿã®èª¿æ•´ã«ä½¿ã†)

  // play state
  let isPlaying = false;
  let currentStep = 0;

  // ====== DOM: ã‚°ãƒªãƒƒãƒ‰ç”Ÿæˆ ======
  const gridEl = $("#grid");

  function buildGrid(){
    gridEl.innerHTML = "";

    // 1è¡Œç›®(ãƒ˜ãƒƒãƒ€): å·¦ä¸Šã¯ç©ºã€å³ã«ã‚¹ãƒ†ãƒƒãƒ—ãƒ©ãƒ™ãƒ«
    const corner = document.createElement("div");
    corner.className = "stepLabel hdr";
    corner.textContent = "";
    gridEl.appendChild(corner);

    for(let s=0; s<STEPS; s++){
      const d = document.createElement("div");
      d.className = "stepLabel hdr";
      d.textContent = (s+1).toString().padStart(2,"0");
      d.dataset.step = String(s);
      gridEl.appendChild(d);
    }

    // éŸ³è¡Œ
    for(let r=0; r<ROWS; r++){
      const pitch = PITCHES[r];
      const lbl = document.createElement("div");
      lbl.className = "pitchLabel";
      const dot = document.createElement("span");
      dot.className = "pitchDot" + (r%2 ? " alt" : "");
      const t = document.createElement("span");
      t.textContent = pitch.name;
      lbl.appendChild(dot);
      lbl.appendChild(t);
      gridEl.appendChild(lbl);

      for(let s=0; s<STEPS; s++){
        const c = document.createElement("div");
        c.className = "cell" + (r%2 ? " alt" : "");
        c.dataset.row = String(r);
        c.dataset.step = String(s);
        c.setAttribute("role","button");
        c.setAttribute("aria-label", `${pitch.name} step ${s+1}`);
        c.tabIndex = 0;

        const toggle = () => {
          grid[r][s] = !grid[r][s];
          c.classList.toggle("on", grid[r][s]);
          saveState();
          if (grid[r][s]) spawnNoteParticle(r, s, 0.6);
        };

        c.addEventListener("click", (e) => { e.preventDefault(); ensureAudio(); toggle(); });
        c.addEventListener("keydown", (e) => {
          if (e.key === "Enter" || e.key === " ") { e.preventDefault(); ensureAudio(); toggle(); }
        });

        gridEl.appendChild(c);
      }
    }
  }

  function syncGridToDOM(){
    const cells = gridEl.querySelectorAll(".cell");
    for(const c of cells){
      const r = +c.dataset.row;
      const s = +c.dataset.step;
      c.classList.toggle("on", !!grid[r][s]);
    }
  }

  function setPlayhead(step){
    const cells = gridEl.querySelectorAll(".cell");
    for(const c of cells){
      const s = +c.dataset.step;
      c.classList.toggle("playhead", s === step);
    }
    // ãƒ˜ãƒƒãƒ€ã‚‚è»½ã
    const hdrs = gridEl.querySelectorAll(".stepLabel.hdr");
    for(let i=1; i<hdrs.length; i++){
      hdrs[i].style.borderColor = (i-1 === step) ? "rgba(120,255,160,.55)" : "rgba(255,255,255,.10)";
      hdrs[i].style.background  = (i-1 === step) ? "rgba(120,255,160,.10)" : "rgba(255,255,255,.03)";
    }
  }

  // ====== localStorage / å…±æœ‰ãƒãƒƒã‚·ãƒ¥ ======
  const LS_KEY = "onefile_sequencer_v1";

  function encodeState(){
    // ãƒ“ãƒƒãƒˆåˆ—: ROWS*STEPS
    let bits = "";
    for(let r=0; r<ROWS; r++){
      for(let s=0; s<STEPS; s++) bits += grid[r][s] ? "1" : "0";
    }
    // 2é€²â†’base64é¢¨ã«åœ§ç¸®ï¼ˆç°¡æ˜“ï¼‰
    // 6bitå˜ä½ã«ã—ã¦URL safe base64
    let out = "";
    for(let i=0; i<bits.length; i+=6){
      const chunk = bits.slice(i,i+6).padEnd(6,"0");
      const n = parseInt(chunk, 2);
      out += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_".charAt(n);
    }
    // ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚‚å«ã‚ã‚‹
    const t = clamp(Math.round(tempo), 60, 180);
    const sw = clamp(swing, 0, 0.45);
    const tn = clamp(tone, 0, 1);
    return `v=1&t=${t}&sw=${sw.toFixed(2)}&tn=${tn.toFixed(2)}&p=${out}`;
  }

  function decodeState(hash){
    // æœŸå¾…å½¢å¼: #v=1&t=120&sw=0.12&tn=0.55&p=....
    const h = hash.replace(/^#/, "").trim();
    if(!h) return null;
    const params = new URLSearchParams(h);
    if(params.get("v") !== "1") return null;

    const p = params.get("p");
    if(!p) return null;

    const t = Number(params.get("t"));
    const sw = Number(params.get("sw"));
    const tn = Number(params.get("tn"));
    if(Number.isFinite(t)) tempo = clamp(t, 60, 180);
    if(Number.isFinite(sw)) swing = clamp(sw, 0, 0.45);
    if(Number.isFinite(tn)) tone = clamp(tn, 0, 1);

    // decode pattern
    const map = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
    let bits = "";
    for(const ch of p){
      const n = map.indexOf(ch);
      if(n < 0) continue;
      bits += n.toString(2).padStart(6,"0");
    }
    // ROWS*STEPS bits ã‚’èª­ã‚€
    const need = ROWS*STEPS;
    bits = bits.slice(0, need).padEnd(need,"0");

    const g = Array.from({length: ROWS}, () => Array.from({length: STEPS}, () => false));
    let idx = 0;
    for(let r=0; r<ROWS; r++){
      for(let s=0; s<STEPS; s++){
        g[r][s] = bits[idx++] === "1";
      }
    }
    return g;
  }

  function saveState(){
    const payload = {
      tempo, swing, tone,
      grid
    };
    try{
      localStorage.setItem(LS_KEY, JSON.stringify(payload));
    }catch(_){}
    updateShareText(false);
  }

  function loadState(){
    // 1) URL hash å„ªå…ˆ
    const fromHash = decodeState(location.hash);
    if(fromHash){
      grid = fromHash;
      toast("URLã‹ã‚‰ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ");
      return;
    }

    // 2) localStorage
    try{
      const raw = localStorage.getItem(LS_KEY);
      if(!raw) return;
      const p = JSON.parse(raw);
      if(p && Array.isArray(p.grid)){
        grid = p.grid;
      }
      if(Number.isFinite(p.tempo)) tempo = clamp(p.tempo, 60, 180);
      if(Number.isFinite(p.swing)) swing = clamp(p.swing, 0, 0.45);
      if(Number.isFinite(p.tone))  tone  = clamp(p.tone, 0, 1);
    }catch(_){}
  }

  function updateShareText(includeHash=true){
    const s = encodeState();
    const url = includeHash
      ? `${location.origin}${location.pathname}#${s}`
      : `#${s}`;
    $("#shareText").textContent = url;
  }

  // ====== WebAudio: åˆæœŸåŒ– ======
  let audio = {
    ctx: null,
    master: null,
    analyser: null,
    data: null,
    compressor: null,
    started: false,
  };

  function setStatus(msg){
    $("#status").textContent = msg;
  }

  function ensureAudio(){
    if(audio.ctx) {
      if(audio.ctx.state === "suspended") audio.ctx.resume().catch(()=>{});
      return;
    }

    const AudioContext = window.AudioContext || window.webkitAudioContext;
    if(!AudioContext){
      setStatus("Audio: éå¯¾å¿œï¼ˆWebAudioãªã—ï¼‰");
      toast("ã“ã®ãƒ–ãƒ©ã‚¦ã‚¶ã§ã¯WebAudioãŒä½¿ãˆã¾ã›ã‚“");
      return;
    }

    const ctx = new AudioContext();
    const master = ctx.createGain();
    master.gain.value = 0.80;

    const compressor = ctx.createDynamicsCompressor();
    compressor.threshold.value = -18;
    compressor.knee.value = 18;
    compressor.ratio.value = 3.5;
    compressor.attack.value = 0.003;
    compressor.release.value = 0.15;

    const analyser = ctx.createAnalyser();
    analyser.fftSize = 2048;
    analyser.smoothingTimeConstant = 0.85;

    master.connect(compressor);
    compressor.connect(analyser);
    analyser.connect(ctx.destination);

    audio.ctx = ctx;
    audio.master = master;
    audio.compressor = compressor;
    audio.analyser = analyser;
    audio.data = new Uint8Array(analyser.frequencyBinCount);

    setStatus("Audio: æº–å‚™OKï¼ˆã‚¯ãƒªãƒƒã‚¯ã§éŸ³ãŒå‡ºã¾ã™ï¼‰");
  }

  // ====== éŸ³ã¥ãã‚Š ======
  function mkVoice(time, hz, vel=0.7){
    const ctx = audio.ctx;
    if(!ctx) return;

    // éŸ³è‰²: tone ã‚’ 0..1 â†’ ãƒ•ã‚£ãƒ«ã‚¿ã®ã‚«ãƒƒãƒˆã‚ªãƒ•ã‚„æ­ªã¿é‡ã«åæ˜ 
    const cutoff = lerp(900, 5200, tone);
    const q = lerp(0.5, 10.0, tone);

    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    const filter = ctx.createBiquadFilter();

    // æ³¢å½¢ãƒŸãƒƒã‚¯ã‚¹ã£ã½ãï¼šodd/even ã§å¤‰ãˆã‚‹
    osc.type = (Math.random() < 0.5) ? "sawtooth" : "triangle";
    osc.frequency.setValueAtTime(hz, time);

    filter.type = "lowpass";
    filter.frequency.setValueAtTime(cutoff, time);
    filter.Q.setValueAtTime(q, time);

    // ADSRï¼ˆçŸ­ã‚ï¼‰
    const a = 0.004;
    const d = 0.09;
    const s = 0.0; // 16åˆ†ã®ãƒ¯ãƒ³ã‚·ãƒ§ãƒƒãƒˆ
    const r = 0.07;

    const peak = 0.18 * vel;
    gain.gain.setValueAtTime(0.0001, time);
    gain.gain.exponentialRampToValueAtTime(peak, time + a);
    gain.gain.exponentialRampToValueAtTime(0.0001, time + a + d + s + r);

    // å°‘ã—ãƒ”ãƒƒãƒãƒ™ãƒ³ãƒ‰ã§â€œé³´ã‚Šâ€ã‚’å‡ºã™
    const bend = lerp(10, 35, tone) * (Math.random()*0.6 + 0.4);
    osc.frequency.setValueAtTime(hz + bend, time);
    osc.frequency.exponentialRampToValueAtTime(hz, time + 0.025);

    osc.connect(filter);
    filter.connect(gain);
    gain.connect(audio.master);

    osc.start(time);
    osc.stop(time + a + d + s + r + 0.03);
  }

  function mkKick(time, vel=0.8){
    const ctx = audio.ctx;
    if(!ctx) return;

    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    const filter = ctx.createBiquadFilter();

    filter.type = "lowpass";
    filter.frequency.setValueAtTime(lerp(900, 1600, tone), time);
    filter.Q.setValueAtTime(0.7, time);

    osc.type = "sine";
    osc.frequency.setValueAtTime(140, time);
    osc.frequency.exponentialRampToValueAtTime(48, time + 0.045);

    gain.gain.setValueAtTime(0.0001, time);
    gain.gain.exponentialRampToValueAtTime(0.55 * vel, time + 0.003);
    gain.gain.exponentialRampToValueAtTime(0.0001, time + 0.14);

    osc.connect(filter);
    filter.connect(gain);
    gain.connect(audio.master);

    osc.start(time);
    osc.stop(time + 0.18);
  }

  function mkSnare(time, vel=0.65){
    const ctx = audio.ctx;
    if(!ctx) return;

    // ãƒã‚¤ã‚º
    const bufferSize = Math.floor(ctx.sampleRate * 0.12);
    const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
    const data = buffer.getChannelData(0);
    for(let i=0; i<bufferSize; i++){
      // ãƒ”ãƒ³ã‚¯ã£ã½ã„é›°å›²æ°—ï¼ˆç°¡æ˜“ï¼‰
      const white = Math.random()*2-1;
      data[i] = white * Math.pow(1 - i/bufferSize, 2.2);
    }
    const noise = ctx.createBufferSource();
    noise.buffer = buffer;

    const hp = ctx.createBiquadFilter();
    hp.type = "highpass";
    hp.frequency.setValueAtTime(1100, time);
    hp.Q.setValueAtTime(0.9, time);

    const gain = ctx.createGain();
    gain.gain.setValueAtTime(0.0001, time);
    gain.gain.exponentialRampToValueAtTime(0.35*vel, time + 0.004);
    gain.gain.exponentialRampToValueAtTime(0.0001, time + 0.11);

    // å°‘ã—ãƒˆãƒ¼ãƒ³ã‚‚æ··ãœã‚‹
    const osc = ctx.createOscillator();
    const og = ctx.createGain();
    osc.type = "triangle";
    osc.frequency.setValueAtTime(180, time);
    og.gain.setValueAtTime(0.0001, time);
    og.gain.exponentialRampToValueAtTime(0.12*vel, time + 0.003);
    og.gain.exponentialRampToValueAtTime(0.0001, time + 0.07);

    noise.connect(hp);
    hp.connect(gain);
    gain.connect(audio.master);

    osc.connect(og);
    og.connect(audio.master);

    noise.start(time);
    noise.stop(time + 0.13);
    osc.start(time);
    osc.stop(time + 0.09);
  }

  function mkHat(time, vel=0.5){
    const ctx = audio.ctx;
    if(!ctx) return;

    const bufferSize = Math.floor(ctx.sampleRate * 0.05);
    const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
    const data = buffer.getChannelData(0);
    for(let i=0; i<bufferSize; i++){
      const white = Math.random()*2-1;
      data[i] = white * (1 - i/bufferSize);
    }
    const noise = ctx.createBufferSource();
    noise.buffer = buffer;

    const bp = ctx.createBiquadFilter();
    bp.type = "bandpass";
    bp.frequency.setValueAtTime(lerp(7000, 11000, tone), time);
    bp.Q.setValueAtTime(6, time);

    const gain = ctx.createGain();
    gain.gain.setValueAtTime(0.0001, time);
    gain.gain.exponentialRampToValueAtTime(0.18*vel, time + 0.002);
    gain.gain.exponentialRampToValueAtTime(0.0001, time + 0.05);

    noise.connect(bp);
    bp.connect(gain);
    gain.connect(audio.master);

    noise.start(time);
    noise.stop(time + 0.06);
  }

  // ====== ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ©ï¼ˆãƒ«ãƒƒã‚¯ã‚¢ãƒ˜ãƒƒãƒ‰ï¼‰ ======
  let nextNoteTime = 0;
  let schedulerTimer = null;

  const LOOKAHEAD_MS = 25;
  const SCHEDULE_AHEAD_S = 0.12;

  function secondsPer16th(){
    // 4/4 ã® 16åˆ†éŸ³ç¬¦: 1æ‹(4åˆ†)ã® 1/4
    const spb = 60 / tempo;     // seconds per beat (quarter)
    return spb / 4;             // 16th
  }

  function scheduleStep(step, time){
    // swing: å¥‡æ•°ã‚¹ãƒ†ãƒƒãƒ—(è£)ã‚’é…ã‚‰ã›ã‚‹
    const swingOffset = (step % 2 === 1) ? (secondsPer16th() * swing) : 0;
    const t = time + swingOffset;

    // éŸ³ï¼ˆã‚°ãƒªãƒƒãƒ‰ï¼‰
    for(let r=0; r<ROWS; r++){
      if(grid[r][step]){
        const vel = 0.70 + (r/ROWS)*0.18;
        mkVoice(t, PITCHES[r].hz, vel);
        spawnNoteParticle(r, step, vel);
      }
    }

    // ãƒ‰ãƒ©ãƒ ï¼ˆå›ºå®šã®ç°¡æ˜“ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼‰
    // Kick: 1, 5, 9, 13
    if(step === 0 || step === 4 || step === 8 || step === 12){
      mkKick(t, 0.9);
      spawnDrumParticle("kick", 0.9);
    }
    // Snare: 5, 13
    if(step === 4 || step === 12){
      mkSnare(t, 0.75);
      spawnDrumParticle("snare", 0.7);
    }
    // Hat: å¶æ•°ã‚¹ãƒ†ãƒƒãƒ—ä¸­å¿ƒ
    if(step % 2 === 0){
      mkHat(t, 0.50);
      spawnDrumParticle("hat", 0.4);
    }
  }

  function scheduler(){
    if(!audio.ctx) return;
    const ctx = audio.ctx;

    while(nextNoteTime < ctx.currentTime + SCHEDULE_AHEAD_S){
      scheduleStep(currentStep, nextNoteTime);

      // UIã®ãƒ—ãƒ¬ã‚¤ãƒ˜ãƒƒãƒ‰ã¯ã€Œå®Ÿæ™‚é–“ã€ã‚ˆã‚Šå°‘ã—é…ã‚Œã¦è¦‹ãˆã‚‹ã‘ã©é›°å›²æ°—é‡è¦–ã§OK
      const stepForUI = currentStep;
      setTimeout(() => { if(isPlaying) setPlayhead(stepForUI); }, 0);

      nextNoteTime += secondsPer16th();
      currentStep = (currentStep + 1) % STEPS;
    }
  }

  function start(){
    ensureAudio();
    if(!audio.ctx) return;

    audio.ctx.resume().catch(()=>{});
    isPlaying = true;
    $("#btnPlay").textContent = "â¸ åœæ­¢";
    setStatus("Audio: å†ç”Ÿä¸­");

    currentStep = currentStep % STEPS;
    nextNoteTime = audio.ctx.currentTime + 0.04;

    clearInterval(schedulerTimer);
    schedulerTimer = setInterval(scheduler, LOOKAHEAD_MS);
  }

  function stop(){
    isPlaying = false;
    $("#btnPlay").textContent = "â–¶ å†ç”Ÿ";
    setStatus(audio.ctx ? "Audio: åœæ­¢ä¸­" : "Audio: æœªåˆæœŸåŒ–");
    clearInterval(schedulerTimer);
    schedulerTimer = null;
    setPlayhead(-1);
  }

  function togglePlay(){
    if(isPlaying) stop();
    else start();
  }

  // ====== UIã‚¤ãƒ™ãƒ³ãƒˆ ======
  $("#btnPlay").addEventListener("click", () => { ensureAudio(); togglePlay(); });

  $("#btnRandom").addEventListener("click", () => {
    ensureAudio();
    // ã»ã©ã‚ˆãéŸ³ãŒåŸ‹ã¾ã‚‹å¯†åº¦
    for(let r=0; r<ROWS; r++){
      for(let s=0; s<STEPS; s++){
        const base = (r < 2) ? 0.14 : (r < 5 ? 0.10 : 0.07);
        grid[r][s] = Math.random() < base;
      }
    }
    // 4æ‹ã®é ­ã¯å°‘ã—å¼·ã‚ã«ç½®ã
    for(const s of [0,4,8,12]){
      const r = Math.floor(Math.random()*3); // ä¸Šã®æ–¹ã§é³´ã‚Šã‚„ã™ã„
      grid[r][s] = true;
    }
    syncGridToDOM();
    saveState();
    toast("ãƒ©ãƒ³ãƒ€ãƒ ç”Ÿæˆã—ã¾ã—ãŸ");
  });

  $("#btnClear").addEventListener("click", () => {
    for(let r=0; r<ROWS; r++) for(let s=0; s<STEPS; s++) grid[r][s] = false;
    syncGridToDOM();
    saveState();
    toast("ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸ");
  });

  const tempoEl = $("#tempo");
  const swingEl = $("#swing");
  const toneEl  = $("#tone");

  tempoEl.addEventListener("input", () => {
    tempo = +tempoEl.value;
    $("#tempoVal").textContent = String(tempo);
    saveState();
  });
  swingEl.addEventListener("input", () => {
    swing = +swingEl.value;
    $("#swingVal").textContent = swing.toFixed(2);
    saveState();
  });
  toneEl.addEventListener("input", () => {
    tone = +toneEl.value;
    $("#toneVal").textContent = tone.toFixed(2);
    saveState();
  });

  $("#btnShare").addEventListener("click", async () => {
    updateShareText(true);
    toast("å…±æœ‰ãƒªãƒ³ã‚¯ã‚’ç”Ÿæˆã—ã¾ã—ãŸ");
  });

  $("#btnCopy").addEventListener("click", async () => {
    updateShareText(true);
    const text = $("#shareText").textContent;
    try{
      await navigator.clipboard.writeText(text);
      toast("ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ");
    }catch(_){
      // fallback: é¸æŠ
      const range = document.createRange();
      range.selectNodeContents($("#shareText"));
      const sel = window.getSelection();
      sel.removeAllRanges();
      sel.addRange(range);
      toast("ã‚³ãƒ”ãƒ¼ã§ããªã„å ´åˆã¯æ‰‹å‹•ã§é¸æŠã—ã¦ã‚³ãƒ”ãƒ¼ã—ã¦ãã ã•ã„");
    }
  });

  window.addEventListener("keydown", (e) => {
    if(e.target && (e.target.tagName === "INPUT" || e.target.tagName === "TEXTAREA")) return;

    if(e.key === " "){
      e.preventDefault();
      ensureAudio();
      togglePlay();
    }
    if(e.key.toLowerCase() === "r"){
      e.preventDefault();
      $("#btnRandom").click();
    }
    if(e.key.toLowerCase() === "c"){
      e.preventDefault();
      $("#btnClear").click();
    }
    if(e.key.toLowerCase() === "s"){
      e.preventDefault();
      $("#btnShare").click();
    }
  });

  // ====== Canvas ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ©ã‚¤ã‚¶ ======
  const canvas = $("#viz");
  const g = canvas.getContext("2d", { alpha: true });

  function resize(){
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.width = Math.floor(window.innerWidth * dpr);
    canvas.height = Math.floor(window.innerHeight * dpr);
    canvas.style.width = "100%";
    canvas.style.height = "100%";
    g.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener("resize", resize);

  // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
  const particles = [];
  class Particle{
    constructor(x,y,vx,vy,r,life,color){
      this.x=x; this.y=y; this.vx=vx; this.vy=vy;
      this.r=r; this.life=life; this.maxLife=life;
      this.color=color;
      this.spin = (Math.random()*2-1)*0.08;
      this.a = Math.random()*Math.PI*2;
    }
    step(dt){
      this.life -= dt;
      this.x += this.vx*dt;
      this.y += this.vy*dt;
      this.vx *= 0.985;
      this.vy *= 0.985;
      this.vy += 12 * dt; // å°‘ã—è½ã¡ã‚‹
      this.a += this.spin;
    }
    draw(ctx){
      const t = clamp(this.life/this.maxLife, 0, 1);
      const alpha = t*t;
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.translate(this.x, this.y);
      ctx.rotate(this.a);
      ctx.fillStyle = this.color;
      ctx.beginPath();
      ctx.arc(0,0,this.r,0,Math.PI*2);
      ctx.fill();
      // å°ã•ãªãƒã‚¤ãƒ©ã‚¤ãƒˆ
      ctx.globalAlpha = alpha*0.55;
      ctx.fillStyle = "rgba(255,255,255,.9)";
      ctx.beginPath();
      ctx.arc(-this.r*0.25,-this.r*0.25, this.r*0.22, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }
  }

  function spawnNoteParticle(row, step, vel){
    const W = window.innerWidth, H = window.innerHeight;
    const x = lerp(W*0.18, W*0.82, step/(STEPS-1));
    const y = lerp(H*0.30, H*0.72, row/(ROWS-1));
    const s = 90 + vel*130;
    const vx = (Math.random()*2-1) * s * 0.22;
    const vy = (Math.random()*2-1) * s * 0.18 - 25;
    const r  = lerp(3.5, 9, vel);
    const life = lerp(0.45, 1.2, vel);
    const color = (row%2===0) ? "rgba(80,220,255,.65)" : "rgba(255,120,220,.62)";
    particles.push(new Particle(x,y,vx,vy,r,life,color));
    if(particles.length > 900) particles.splice(0, particles.length-900);
  }
  function spawnDrumParticle(kind, vel){
    const W = window.innerWidth, H = window.innerHeight;
    let x = W*0.5, y = H*0.82, color="rgba(120,255,160,.55)", r=8;
    if(kind==="kick"){ x=W*0.35; color="rgba(120,255,160,.55)"; r=10; }
    if(kind==="snare"){ x=W*0.50; color="rgba(255,200,120,.55)"; r=8; }
    if(kind==="hat"){ x=W*0.65; color="rgba(180,200,255,.45)"; r=6; }
    const s = 110 + vel*170;
    const vx = (Math.random()*2-1) * s*0.18;
    const vy = (Math.random()*2-1) * s*0.10 - 55;
    const life = lerp(0.25, 0.70, vel);
    particles.push(new Particle(x,y,vx,vy,r,life,color));
  }

  // èƒŒæ™¯ã®â€œæ˜Ÿâ€ã£ã½ã„ç²’
  const stars = Array.from({length: 140}, () => ({
    x: Math.random(),
    y: Math.random(),
    z: Math.random(),
    s: Math.random()*1.2 + 0.2
  }));

  let lastT = performance.now();
  function draw(){
    const now = performance.now();
    const dt = Math.min(0.034, (now - lastT) / 1000);
    lastT = now;

    const W = window.innerWidth;
    const H = window.innerHeight;

    // ã¡ã‚‡ã„æ®‹åƒ
    g.fillStyle = "rgba(0,0,0,0.12)";
    g.fillRect(0,0,W,H);

    // Audio è§£æ
    let energy = 0;
    if(audio.analyser){
      audio.analyser.getByteFrequencyData(audio.data);
      // ã–ã£ãã‚Šä½ã€œä¸­åŸŸã®å¹³å‡
      const d = audio.data;
      let sum = 0;
      const from = 2, to = Math.min(d.length-1, 90);
      for(let i=from; i<=to; i++) sum += d[i];
      energy = sum / (to - from + 1) / 255; // 0..1
    }

    // æ˜Ÿï¼ˆenergyã§æµã‚ŒãŒå¼·ãï¼‰
    const drift = lerp(0.008, 0.06, energy);
    g.save();
    for(const st of stars){
      st.y += drift * (0.25 + st.z*1.25);
      if(st.y > 1) st.y -= 1;

      const x = st.x * W;
      const y = st.y * H;
      const a = lerp(0.10, 0.55, st.z) * (0.35 + energy*0.9);

      g.globalAlpha = a;
      g.fillStyle = "rgba(255,255,255,1)";
      g.fillRect(x, y, st.s*(0.6+st.z*1.2), st.s*(0.6+st.z*1.2));
    }
    g.restore();

    // æ³¢å½¢ãƒ©ã‚¤ãƒ³ï¼ˆã†ã£ã™ã‚‰ï¼‰
    if(audio.analyser){
      const buffer = new Uint8Array(audio.analyser.fftSize);
      audio.analyser.getByteTimeDomainData(buffer);
      g.save();
      g.globalAlpha = 0.18 + energy*0.18;
      g.strokeStyle = "rgba(120,255,160,.9)";
      g.lineWidth = 1.5;
      g.beginPath();
      for(let i=0; i<buffer.length; i++){
        const t = i/(buffer.length-1);
        const x = t * W;
        const v = (buffer[i]-128)/128; // -1..1
        const y = H*0.18 + v * (34 + energy*46);
        if(i===0) g.moveTo(x,y);
        else g.lineTo(x,y);
      }
      g.stroke();
      g.restore();
    }

    // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
    for(let i=particles.length-1; i>=0; i--){
      const p = particles[i];
      p.step(dt);
      if(p.life <= 0){
        particles.splice(i,1);
      }else{
        p.draw(g);
      }
    }

    requestAnimationFrame(draw);
  }

  // ====== èµ·å‹•å‡¦ç† ======
  loadState();
  buildGrid();
  syncGridToDOM();

  // UIåæ˜ 
  tempoEl.value = String(tempo);
  swingEl.value = String(swing);
  toneEl.value  = String(tone);
  $("#tempoVal").textContent = String(tempo);
  $("#swingVal").textContent = swing.toFixed(2);
  $("#toneVal").textContent  = tone.toFixed(2);

  updateShareText(false);
  resize();
  // æœ€åˆã¯çœŸã£é»’ã«ãªã‚‰ãªã„ã‚ˆã†ã«è–„ãå¡—ã‚‹
  g.fillStyle = "rgba(0,0,0,1)";
  g.fillRect(0,0,window.innerWidth, window.innerHeight);
  requestAnimationFrame(draw);

  // hash å¤‰æ›´ã‚’ç›£è¦–ï¼ˆå…±æœ‰ãƒªãƒ³ã‚¯ã‚’è²¼ã‚Šä»˜ã‘ã¦é–‹ãç›´ã•ãªãã¦ã‚‚åæ˜ ã§ãã‚‹ï¼‰
  window.addEventListener("hashchange", () => {
    const g2 = decodeState(location.hash);
    if(g2){
      grid = g2;
      syncGridToDOM();
      tempoEl.value = String(tempo);
      swingEl.value = String(swing);
      toneEl.value  = String(tone);
      $("#tempoVal").textContent = String(tempo);
      $("#swingVal").textContent = swing.toFixed(2);
      $("#toneVal").textContent  = tone.toFixed(2);
      saveState();
      toast("ãƒãƒƒã‚·ãƒ¥ã‹ã‚‰ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’åæ˜ ã—ã¾ã—ãŸ");
    }
  });

})();
</script>
</body>
</html> -->










<!-- <h2>Claude ã«ã‚ˆã‚‹</h2> -->

<!-- 
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cosmic Symphony - å®‡å®™äº¤éŸ¿æ›²</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            overflow: hidden;
            background: #000;
            font-family: 'Courier New', monospace;
        }
        canvas {
            display: block;
        }
        #ui {
            position: fixed;
            bottom: 20px;
            left: 20px;
            color: rgba(255,255,255,0.8);
            font-size: 12px;
            z-index: 100;
            pointer-events: none;
            text-shadow: 0 0 10px rgba(100,150,255,0.5);
        }
        #title {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255,255,255,0.9);
            font-size: 24px;
            z-index: 100;
            pointer-events: none;
            text-shadow: 0 0 20px rgba(100,150,255,0.8);
            letter-spacing: 8px;
        }
        #typed {
            position: fixed;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(150,200,255,0.7);
            font-size: 16px;
            z-index: 100;
            pointer-events: none;
            max-width: 80%;
            text-align: center;
            word-wrap: break-word;
            text-shadow: 0 0 15px rgba(100,150,255,0.6);
        }
        #time {
            position: fixed;
            top: 20px;
            right: 20px;
            color: rgba(255,200,100,0.8);
            font-size: 14px;
            z-index: 100;
            pointer-events: none;
        }
        .fade-in {
            animation: fadeIn 2s ease-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
    </style>
</head>
<body>
    <div id="title" class="fade-in">C O S M I C Â· S Y M P H O N Y</div>
    <div id="typed"></div>
    <div id="time"></div>
    <div id="ui">
        [ãƒã‚¦ã‚¹ç§»å‹•] å®‡å®™ã‚’è¦‹æ¸¡ã™<br>
        [ã‚¯ãƒªãƒƒã‚¯] è¶…æ–°æ˜Ÿçˆ†ç™º<br>
        [ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰] æ˜Ÿã‚’å‰µé€ ã—éŸ³ã‚’å¥ã§ã‚‹<br>
        [ã‚¹ãƒšãƒ¼ã‚¹] æ™‚é–“åŠ é€Ÿ<br>
        [Esc] ãƒªã‚»ãƒƒãƒˆ
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // ===== ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã‚·ã‚¹ãƒ†ãƒ  =====
        class CosmicAudio {
            constructor() {
                this.ctx = null;
                this.masterGain = null;
                this.reverbNode = null;
                this.initialized = false;
            }

            async init() {
                if (this.initialized) return;
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = 0.3;
                
                // ãƒªãƒãƒ¼ãƒ–ä½œæˆ
                this.reverbNode = this.ctx.createConvolver();
                const reverbBuffer = this.createReverbImpulse(3, 2);
                this.reverbNode.buffer = reverbBuffer;
                
                const reverbGain = this.ctx.createGain();
                reverbGain.gain.value = 0.4;
                
                this.reverbNode.connect(reverbGain);
                reverbGain.connect(this.masterGain);
                this.masterGain.connect(this.ctx.destination);
                
                this.initialized = true;
            }

            createReverbImpulse(duration, decay) {
                const rate = this.ctx.sampleRate;
                const length = rate * duration;
                const impulse = this.ctx.createBuffer(2, length, rate);
                
                for (let channel = 0; channel < 2; channel++) {
                    const data = impulse.getChannelData(channel);
                    for (let i = 0; i < length; i++) {
                        data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, decay);
                    }
                }
                return impulse;
            }

            playNote(frequency, type = 'sine', duration = 2) {
                if (!this.initialized) return;
                
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();
                
                osc.type = type;
                osc.frequency.setValueAtTime(frequency, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(
                    frequency * 0.5, 
                    this.ctx.currentTime + duration
                );
                
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(2000, this.ctx.currentTime);
                filter.frequency.exponentialRampToValueAtTime(200, this.ctx.currentTime + duration);
                
                gain.gain.setValueAtTime(0.5, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
                
                osc.connect(filter);
                filter.connect(gain);
                gain.connect(this.masterGain);
                gain.connect(this.reverbNode);
                
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            }

            playExplosion() {
                if (!this.initialized) return;
                
                // ãƒã‚¤ã‚ºçˆ†ç™ºéŸ³
                const bufferSize = this.ctx.sampleRate * 2;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / bufferSize, 3);
                }
                
                const source = this.ctx.createBufferSource();
                source.buffer = buffer;
                
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(1000, this.ctx.currentTime);
                filter.frequency.exponentialRampToValueAtTime(100, this.ctx.currentTime + 1.5);
                
                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(0.8, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 2);
                
                source.connect(filter);
                filter.connect(gain);
                gain.connect(this.masterGain);
                gain.connect(this.reverbNode);
                
                source.start();
                
                // ä½éŸ³ã®è¡æ’ƒæ³¢
                const osc = this.ctx.createOscillator();
                const oscGain = this.ctx.createGain();
                osc.frequency.setValueAtTime(80, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(20, this.ctx.currentTime + 1);
                oscGain.gain.setValueAtTime(0.5, this.ctx.currentTime);
                oscGain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 1);
                osc.connect(oscGain);
                oscGain.connect(this.masterGain);
                osc.start();
                osc.stop(this.ctx.currentTime + 1);
            }

            playAmbient() {
                if (!this.initialized) return;
                
                const frequencies = [55, 82.5, 110, 165];
                frequencies.forEach((freq, i) => {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    
                    osc.type = 'sine';
                    osc.frequency.value = freq;
                    gain.gain.value = 0.02;
                    
                    // LFOã§ã‚†ã‚‰ãã‚’ä½œæˆ
                    const lfo = this.ctx.createOscillator();
                    const lfoGain = this.ctx.createGain();
                    lfo.frequency.value = 0.1 + i * 0.05;
                    lfoGain.gain.value = freq * 0.02;
                    lfo.connect(lfoGain);
                    lfoGain.connect(osc.frequency);
                    
                    osc.connect(gain);
                    gain.connect(this.masterGain);
                    
                    osc.start();
                    lfo.start();
                });
            }
        }

        // ===== ãƒ¡ã‚¤ãƒ³ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ =====
        class CosmicSymphony {
            constructor() {
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
                this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                this.composer = null;
                this.audio = new CosmicAudio();
                
                this.stars = [];
                this.nebulae = [];
                this.particles = [];
                this.floatingTexts = [];
                this.explosions = [];
                this.orbitingObjects = [];
                
                this.mouse = { x: 0, y: 0 };
                this.targetRotation = { x: 0, y: 0 };
                this.currentRotation = { x: 0, y: 0 };
                
                this.time = 0;
                this.timeSpeed = 1;
                this.typedText = '';
                this.cosmicAge = 0;
                
                this.keyNotes = this.generateKeyNotes();
                this.colors = [
                    0xff6b6b, 0x4ecdc4, 0x45b7d1, 0x96ceb4, 
                    0xffeaa7, 0xdfe6e9, 0xff7675, 0x74b9ff,
                    0xa29bfe, 0xfd79a8, 0x00b894, 0xe17055
                ];
                
                this.init();
            }

            generateKeyNotes() {
                const notes = {};
                const baseFreq = 130.81; // C3
                const keys = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
                const pentatonic = [0, 2, 4, 7, 9]; // ãƒšãƒ³ã‚¿ãƒˆãƒ‹ãƒƒã‚¯ã‚¹ã‚±ãƒ¼ãƒ«
                
                keys.split('').forEach((key, i) => {
                    const octave = Math.floor(i / 5);
                    const noteIndex = pentatonic[i % 5];
                    notes[key] = baseFreq * Math.pow(2, (noteIndex + octave * 12) / 12);
                });
                
                return notes;
            }

            init() {
                // ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼è¨­å®š
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
                document.body.appendChild(this.renderer.domElement);
                
                // ã‚«ãƒ¡ãƒ©ä½ç½®
                this.camera.position.z = 100;
                
                // ãƒã‚¹ãƒˆãƒ—ãƒ­ã‚»ãƒƒã‚·ãƒ³ã‚°ï¼ˆãƒ–ãƒ«ãƒ¼ãƒ åŠ¹æœï¼‰
                this.composer = new EffectComposer(this.renderer);
                this.composer.addPass(new RenderPass(this.scene, this.camera));
                
                const bloomPass = new UnrealBloomPass(
                    new THREE.Vector2(window.innerWidth, window.innerHeight),
                    1.5, 0.4, 0.85
                );
                bloomPass.threshold = 0;
                bloomPass.strength = 2;
                bloomPass.radius = 1;
                this.composer.addPass(bloomPass);
                
                // åˆæœŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆä½œæˆ
                this.createStarField();
                this.createNebula();
                this.createCentralObject();
                this.createOrbitingRings();
                
                // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
                this.setupEventListeners();
                
                // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹
                this.animate();
            }

            createStarField() {
                const geometry = new THREE.BufferGeometry();
                const vertices = [];
                const colors = [];
                const sizes = [];
                
                for (let i = 0; i < 15000; i++) {
                    const radius = 500 + Math.random() * 2000;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    
                    vertices.push(
                        radius * Math.sin(phi) * Math.cos(theta),
                        radius * Math.sin(phi) * Math.sin(theta),
                        radius * Math.cos(phi)
                    );
                    
                    const color = new THREE.Color();
                    color.setHSL(Math.random() * 0.2 + 0.5, 0.5, 0.8 + Math.random() * 0.2);
                    colors.push(color.r, color.g, color.b);
                    
                    sizes.push(Math.random() * 2 + 0.5);
                }
                
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
                
                const material = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        pixelRatio: { value: this.renderer.getPixelRatio() }
                    },
                    vertexShader: `
                        attribute float size;
                        attribute vec3 color;
                        varying vec3 vColor;
                        uniform float time;
                        uniform float pixelRatio;
                        
                        void main() {
                            vColor = color;
                            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                            float twinkle = sin(time * 2.0 + position.x * 0.01) * 0.5 + 0.5;
                            gl_PointSize = size * pixelRatio * (300.0 / -mvPosition.z) * (0.5 + twinkle * 0.5);
                            gl_Position = projectionMatrix * mvPosition;
                        }
                    `,
                    fragmentShader: `
                        varying vec3 vColor;
                        
                        void main() {
                            float dist = length(gl_PointCoord - vec2(0.5));
                            if (dist > 0.5) discard;
                            float alpha = 1.0 - smoothstep(0.0, 0.5, dist);
                            gl_FragColor = vec4(vColor, alpha);
                        }
                    `,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                
                this.starField = new THREE.Points(geometry, material);
                this.scene.add(this.starField);
            }

            createNebula() {
                const nebulaGroup = new THREE.Group();
                
                for (let n = 0; n < 5; n++) {
                    const geometry = new THREE.BufferGeometry();
                    const vertices = [];
                    const colors = [];
                    
                    const nebulaColor = new THREE.Color();
                    nebulaColor.setHSL(Math.random(), 0.8, 0.5);
                    
                    const centerX = (Math.random() - 0.5) * 400;
                    const centerY = (Math.random() - 0.5) * 400;
                    const centerZ = (Math.random() - 0.5) * 400 - 200;
                    
                    for (let i = 0; i < 2000; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const radius = Math.random() * 100;
                        const height = (Math.random() - 0.5) * 50;
                        
                        vertices.push(
                            centerX + Math.cos(angle) * radius,
                            centerY + height,
                            centerZ + Math.sin(angle) * radius
                        );
                        
                        const c = nebulaColor.clone();
                        c.offsetHSL(Math.random() * 0.1 - 0.05, 0, Math.random() * 0.2);
                        colors.push(c.r, c.g, c.b);
                    }
                    
                    geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                    geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                    
                    const material = new THREE.PointsMaterial({
                        size: 3,
                        vertexColors: true,
                        transparent: true,
                        opacity: 0.3,
                        blending: THREE.AdditiveBlending,
                        depthWrite: false
                    });
                    
                    const nebula = new THREE.Points(geometry, material);
                    nebula.userData = { rotationSpeed: (Math.random() - 0.5) * 0.001 };
                    nebulaGroup.add(nebula);
                    this.nebulae.push(nebula);
                }
                
                this.scene.add(nebulaGroup);
            }

            createCentralObject() {
                // ä¸­å¿ƒã®ã‚³ã‚¢
                const coreGeometry = new THREE.IcosahedronGeometry(8, 2);
                const coreMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 }
                    },
                    vertexShader: `
                        varying vec3 vNormal;
                        varying vec3 vPosition;
                        uniform float time;
                        
                        void main() {
                            vNormal = normal;
                            vPosition = position;
                            
                            vec3 pos = position;
                            float displacement = sin(pos.x * 2.0 + time) * sin(pos.y * 2.0 + time) * 0.5;
                            pos += normal * displacement;
                            
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                        }
                    `,
                    fragmentShader: `
                        varying vec3 vNormal;
                        varying vec3 vPosition;
                        uniform float time;
                        
                        void main() {
                            vec3 color1 = vec3(0.2, 0.5, 1.0);
                            vec3 color2 = vec3(1.0, 0.3, 0.5);
                            vec3 color3 = vec3(0.3, 1.0, 0.5);
                            
                            float t = sin(time * 0.5) * 0.5 + 0.5;
                            vec3 color = mix(mix(color1, color2, t), color3, sin(time * 0.3) * 0.5 + 0.5);
                            
                            float fresnel = pow(1.0 - abs(dot(vNormal, vec3(0.0, 0.0, 1.0))), 2.0);
                            color += fresnel * 0.5;
                            
                            gl_FragColor = vec4(color, 1.0);
                        }
                    `,
                    wireframe: true
                });
                
                this.centralCore = new THREE.Mesh(coreGeometry, coreMaterial);
                this.scene.add(this.centralCore);
                
                // ã‚°ãƒ­ãƒ¼åŠ¹æœ
                const glowGeometry = new THREE.SphereGeometry(12, 32, 32);
                const glowMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 }
                    },
                    vertexShader: `
                        varying vec3 vNormal;
                        void main() {
                            vNormal = normalize(normalMatrix * normal);
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        varying vec3 vNormal;
                        uniform float time;
                        void main() {
                            float intensity = pow(0.7 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 2.0);
                            vec3 color = vec3(0.3, 0.6, 1.0) * intensity;
                            color += vec3(sin(time) * 0.1 + 0.1, 0.0, cos(time) * 0.1 + 0.1);
                            gl_FragColor = vec4(color, intensity * 0.5);
                        }
                    `,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    side: THREE.BackSide,
                    depthWrite: false
                });
                
                this.centralGlow = new THREE.Mesh(glowGeometry, glowMaterial);
                this.scene.add(this.centralGlow);
            }

            createOrbitingRings() {
                for (let i = 0; i < 3; i++) {
                    const radius = 20 + i * 10;
                    const geometry = new THREE.TorusGeometry(radius, 0.3, 16, 100);
                    const material = new THREE.MeshBasicMaterial({
                        color: new THREE.Color().setHSL(i * 0.3, 0.8, 0.6),
                        transparent: true,
                        opacity: 0.6
                    });
                    
                    const ring = new THREE.Mesh(geometry, material);
                    ring.rotation.x = Math.PI / 2 + i * 0.3;
                    ring.rotation.y = i * 0.5;
                    ring.userData = { 
                        rotationSpeedX: 0.002 * (i + 1),
                        rotationSpeedY: 0.003 * (i + 1)
                    };
                    
                    this.scene.add(ring);
                    this.orbitingObjects.push(ring);
                    
                    // ãƒªãƒ³ã‚°ä¸Šã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
                    for (let j = 0; j < 20; j++) {
                        const angle = (j / 20) * Math.PI * 2;
                        const particleGeometry = new THREE.SphereGeometry(0.5, 8, 8);
                        const particleMaterial = new THREE.MeshBasicMaterial({
                            color: material.color,
                            transparent: true,
                            opacity: 0.8
                        });
                        const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                        particle.position.x = Math.cos(angle) * radius;
                        particle.position.z = Math.sin(angle) * radius;
                        ring.add(particle);
                    }
                }
            }

            createStar(position, color, size = 1) {
                const geometry = new THREE.OctahedronGeometry(size, 0);
                const material = new THREE.MeshBasicMaterial({ 
                    color: color,
                    transparent: true,
                    opacity: 1
                });
                
                const star = new THREE.Mesh(geometry, material);
                star.position.copy(position);
                star.userData = {
                    birthTime: this.time,
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.5,
                        (Math.random() - 0.5) * 0.5,
                        (Math.random() - 0.5) * 0.5
                    ),
                    rotationSpeed: new THREE.Vector3(
                        Math.random() * 0.05,
                        Math.random() * 0.05,
                        Math.random() * 0.05
                    ),
                    pulseSpeed: Math.random() * 2 + 1,
                    baseScale: size
                };
                
                this.scene.add(star);
                this.stars.push(star);
                
                // ã‚°ãƒ­ãƒ¼è¿½åŠ 
                const glowGeometry = new THREE.SphereGeometry(size * 2, 16, 16);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.3,
                    blending: THREE.AdditiveBlending
                });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                star.add(glow);
                
                return star;
            }

            createFloatingText(char, position, color) {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = 128;
                canvas.height = 128;
                
                ctx.fillStyle = '#' + color.toString(16).padStart(6, '0');
                ctx.font = 'bold 80px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(char, 64, 64);
                
                const texture = new THREE.CanvasTexture(canvas);
                const material = new THREE.SpriteMaterial({ 
                    map: texture, 
                    transparent: true,
                    blending: THREE.AdditiveBlending
                });
                const sprite = new THREE.Sprite(material);
                
                sprite.position.copy(position);
                sprite.scale.set(5, 5, 1);
                sprite.userData = {
                    birthTime: this.time,
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.3,
                        Math.random() * 0.5 + 0.2,
                        (Math.random() - 0.5) * 0.3
                    )
                };
                
                this.scene.add(sprite);
                this.floatingTexts.push(sprite);
            }

            createExplosion(position) {
                const particleCount = 200;
                const geometry = new THREE.BufferGeometry();
                const vertices = [];
                const colors = [];
                const velocities = [];
                
                for (let i = 0; i < particleCount; i++) {
                    vertices.push(position.x, position.y, position.z);
                    
                    const color = new THREE.Color();
                    color.setHSL(Math.random() * 0.2 + 0.05, 1, 0.5 + Math.random() * 0.5);
                    colors.push(color.r, color.g, color.b);
                    
                    const phi = Math.random() * Math.PI * 2;
                    const theta = Math.acos(2 * Math.random() - 1);
                    const speed = Math.random() * 3 + 1;
                    
                    velocities.push(
                        Math.sin(theta) * Math.cos(phi) * speed,
                        Math.sin(theta) * Math.sin(phi) * speed,
                        Math.cos(theta) * speed
                    );
                }
                
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                
                const material = new THREE.PointsMaterial({
                    size: 2,
                    vertexColors: true,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                
                const explosion = new THREE.Points(geometry, material);
                explosion.userData = {
                    birthTime: this.time,
                    velocities: velocities
                };
                
                this.scene.add(explosion);
                this.explosions.push(explosion);
                
                // è¡æ’ƒæ³¢ãƒªãƒ³ã‚°
                const ringGeometry = new THREE.RingGeometry(0.1, 2, 64);
                const ringMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffaa00,
                    transparent: true,
                    opacity: 1,
                    side: THREE.DoubleSide,
                    blending: THREE.AdditiveBlending
                });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.position.copy(position);
                ring.lookAt(this.camera.position);
                ring.userData = { birthTime: this.time };
                
                this.scene.add(ring);
                this.explosions.push(ring);
            }

            setupEventListeners() {
                // ãƒã‚¦ã‚¹ç§»å‹•
                window.addEventListener('mousemove', (e) => {
                    this.mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                    this.mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
                    
                    this.targetRotation.x = this.mouse.y * 0.5;
                    this.targetRotation.y = this.mouse.x * 0.5;
                });
                
                // ã‚¯ãƒªãƒƒã‚¯
                window.addEventListener('click', async (e) => {
                    await this.audio.init();
                    
                    const vector = new THREE.Vector3(
                        (e.clientX / window.innerWidth) * 2 - 1,
                        -(e.clientY / window.innerHeight) * 2 + 1,
                        0.5
                    );
                    vector.unproject(this.camera);
                    const dir = vector.sub(this.camera.position).normalize();
                    const distance = 50 + Math.random() * 50;
                    const position = this.camera.position.clone().add(dir.multiplyScalar(distance));
                    
                    this.createExplosion(position);
                    this.audio.playExplosion();
                    
                    // çˆ†ç™ºã§æ–°ã—ã„æ˜Ÿã‚’ç”Ÿæˆ
                    for (let i = 0; i < 5; i++) {
                        setTimeout(() => {
                            const offset = new THREE.Vector3(
                                (Math.random() - 0.5) * 30,
                                (Math.random() - 0.5) * 30,
                                (Math.random() - 0.5) * 30
                            );
                            const starPos = position.clone().add(offset);
                            const color = this.colors[Math.floor(Math.random() * this.colors.length)];
                            this.createStar(starPos, color, Math.random() * 1.5 + 0.5);
                        }, i * 100);
                    }
                });
                
                // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰
                window.addEventListener('keydown', async (e) => {
                    await this.audio.init();
                    
                    const key = e.key.toUpperCase();
                    
                    if (e.key === ' ') {
                        e.preventDefault();
                        this.timeSpeed = this.timeSpeed === 1 ? 5 : 1;
                        return;
                    }
                    
                    if (e.key === 'Escape') {
                        location.reload();
                        return;
                    }
                    
                    if (this.keyNotes[key]) {
                        // éŸ³ã‚’é³´ã‚‰ã™
                        const waveforms = ['sine', 'triangle', 'sawtooth'];
                        const waveform = waveforms[Math.floor(Math.random() * waveforms.length)];
                        this.audio.playNote(this.keyNotes[key], waveform, 2 + Math.random());
                        
                        // æ˜Ÿã‚’ç”Ÿæˆ
                        const position = new THREE.Vector3(
                            (Math.random() - 0.5) * 80,
                            (Math.random() - 0.5) * 80,
                            (Math.random() - 0.5) * 80
                        );
                        const color = this.colors[Math.floor(Math.random() * this.colors.length)];
                        this.createStar(position, color, Math.random() * 2 + 1);
                        
                        // æµ®éŠãƒ†ã‚­ã‚¹ãƒˆ
                        const textPos = position.clone();
                        textPos.z += 5;
                        this.createFloatingText(key, textPos, color);
                        
                        // ã‚¿ã‚¤ãƒ—è¡¨ç¤ºã‚’æ›´æ–°
                        this.typedText += key;
                        if (this.typedText.length > 50) {
                            this.typedText = this.typedText.slice(-50);
                        }
                        document.getElementById('typed').textContent = this.typedText;
                        
                        this.cosmicAge++;
                    }
                });
                
                // ãƒªã‚µã‚¤ã‚º
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                    this.composer.setSize(window.innerWidth, window.innerHeight);
                });
                
                // åˆå›ã‚¯ãƒªãƒƒã‚¯ã§ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªé–‹å§‹
                window.addEventListener('click', async () => {
                    await this.audio.init();
                    this.audio.playAmbient();
                }, { once: true });
            }

            updateObjects(delta) {
                // æ˜Ÿã®æ›´æ–°
                this.stars = this.stars.filter(star => {
                    const age = this.time - star.userData.birthTime;
                    
                    if (age > 60) {
                        this.scene.remove(star);
                        return false;
                    }
                    
                    // ç§»å‹•
                    star.position.add(star.userData.velocity);
                    
                    // å›è»¢
                    star.rotation.x += star.userData.rotationSpeed.x;
                    star.rotation.y += star.userData.rotationSpeed.y;
                    star.rotation.z += star.userData.rotationSpeed.z;
                    
                    // ãƒ‘ãƒ«ã‚¹
                    const pulse = Math.sin(this.time * star.userData.pulseSpeed) * 0.2 + 1;
                    const scale = star.userData.baseScale * pulse;
                    star.scale.set(scale, scale, scale);
                    
                    // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆ
                    if (age > 50) {
                        star.material.opacity = 1 - (age - 50) / 10;
                    }
                    
                    return true;
                });
                
                // æµ®éŠãƒ†ã‚­ã‚¹ãƒˆã®æ›´æ–°
                this.floatingTexts = this.floatingTexts.filter(text => {
                    const age = this.time - text.userData.birthTime;
                    
                    if (age > 10) {
                        this.scene.remove(text);
                        return false;
                    }
                    
                    text.position.add(text.userData.velocity);
                    text.material.opacity = 1 - age / 10;
                    text.scale.multiplyScalar(1.01);
                    
                    return true;
                });
                
                // çˆ†ç™ºã®æ›´æ–°
                this.explosions = this.explosions.filter(obj => {
                    const age = this.time - obj.userData.birthTime;
                    
                    if (age > 5) {
                        this.scene.remove(obj);
                        return false;
                    }
                    
                    if (obj instanceof THREE.Points) {
                        const positions = obj.geometry.attributes.position.array;
                        const velocities = obj.userData.velocities;
                        
                        for (let i = 0; i < positions.length; i += 3) {
                            positions[i] += velocities[i] * 0.5;
                            positions[i + 1] += velocities[i + 1] * 0.5;
                            positions[i + 2] += velocities[i + 2] * 0.5;
                            
                            velocities[i] *= 0.98;
                            velocities[i + 1] *= 0.98;
                            velocities[i + 2] *= 0.98;
                        }
                        
                        obj.geometry.attributes.position.needsUpdate = true;
                        obj.material.opacity = 1 - age / 5;
                    } else if (obj instanceof THREE.Mesh) {
                        // è¡æ’ƒæ³¢ãƒªãƒ³ã‚°
                        const scale = 1 + age * 20;
                        obj.scale.set(scale, scale, 1);
                        obj.material.opacity = 1 - age / 3;
                    }
                    
                    return true;
                });
                
                // è»Œé“ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æ›´æ–°
                this.orbitingObjects.forEach(obj => {
                    obj.rotation.x += obj.userData.rotationSpeedX * this.timeSpeed;
                    obj.rotation.y += obj.userData.rotationSpeedY * this.timeSpeed;
                });
                
                // æ˜Ÿé›²ã®æ›´æ–°
                this.nebulae.forEach(nebula => {
                    nebula.rotation.y += nebula.userData.rotationSpeed * this.timeSpeed;
                });
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                
                const delta = 0.016 * this.timeSpeed;
                this.time += delta;
                
                // ã‚«ãƒ¡ãƒ©ã®æ»‘ã‚‰ã‹ãªå›è»¢
                this.currentRotation.x += (this.targetRotation.x - this.currentRotation.x) * 0.05;
                this.currentRotation.y += (this.targetRotation.y - this.currentRotation.y) * 0.05;
                
                this.camera.position.x = Math.sin(this.currentRotation.y) * 100;
                this.camera.position.y = Math.sin(this.currentRotation.x) * 50;
                this.camera.position.z = Math.cos(this.currentRotation.y) * 100;
                this.camera.lookAt(0, 0, 0);
                
                // ä¸­å¿ƒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æ›´æ–°
                if (this.centralCore) {
                    this.centralCore.rotation.x += 0.005 * this.timeSpeed;
                    this.centralCore.rotation.y += 0.007 * this.timeSpeed;
                    this.centralCore.material.uniforms.time.value = this.time;
                }
                
                if (this.centralGlow) {
                    this.centralGlow.material.uniforms.time.value = this.time;
                    const scale = 1 + Math.sin(this.time * 0.5) * 0.1;
                    this.centralGlow.scale.set(scale, scale, scale);
                }
                
                // æ˜Ÿç©ºã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                if (this.starField) {
                    this.starField.material.uniforms.time.value = this.time;
                    this.starField.rotation.y += 0.0001 * this.timeSpeed;
                }
                
                // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæ›´æ–°
                this.updateObjects(delta);
                
                // æ™‚é–“è¡¨ç¤ºæ›´æ–°
                const eons = Math.floor(this.time / 10);
                const stars = this.stars.length;
                document.getElementById('time').innerHTML = `
                    å®‡å®™å¹´é½¢: ${eons.toLocaleString()} ã‚¨ã‚ªãƒ³<br>
                    å‰µé€ ã•ã‚ŒãŸæ˜Ÿ: ${this.cosmicAge}<br>
                    ç¾å­˜ã™ã‚‹æ˜Ÿ: ${stars}
                `;
                
                this.composer.render();
            }
        }

        // ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹
        new CosmicSymphony();
    </script>
</body>
</html> -->










<!-- <h2>Gemini ã«ã‚ˆã‚‹</h2> -->

<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Audio Visualizer & Synth</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #f0f2f5; /* æ˜ã‚‹ã„èƒŒæ™¯ */
            font-family: 'Helvetica Neue', Arial, sans-serif;
            user-select: none;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: block;
        }

        /* UI Overlay */
        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.85);
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
            transition: opacity 0.5s ease;
        }

        h1 {
            color: #333;
            font-weight: 200;
            letter-spacing: 2px;
            margin-bottom: 30px;
            text-align: center;
        }

        .btn-group {
            display: flex;
            gap: 20px;
        }

        button {
            padding: 15px 30px;
            font-size: 16px;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            outline: none;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(118, 75, 162, 0.4);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(118, 75, 162, 0.6);
        }

        #status {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #888;
            font-size: 12px;
            pointer-events: none;
        }

        #instruction {
            margin-top: 20px;
            font-size: 14px;
            color: #666;
            text-align: center;
            line-height: 1.6;
        }

        .hidden {
            opacity: 0;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <!-- UI Overlay -->
    <div id="overlay">
        <h1>INTERACTIVE AUDIO FLOW</h1>
        <div class="btn-group">
            <button id="btn-mic">ãƒã‚¤ã‚¯å…¥åŠ›ã§é–‹å§‹</button>
            <button id="btn-sys">PCå†…éƒ¨éŸ³å£°ã§é–‹å§‹</button>
        </div>
        <div id="instruction">
            â€»PCå†…éƒ¨éŸ³å£°ã®å ´åˆã€å…±æœ‰ç”»é¢ã§<b>ã€ŒéŸ³å£°ã‚’å…±æœ‰ã€</b>ã«ãƒã‚§ãƒƒã‚¯ã‚’å…¥ã‚Œã¦ãã ã•ã„ã€‚<br>
            ãƒã‚¦ã‚¹ç§»å‹•ãƒ»ã‚¯ãƒªãƒƒã‚¯ãƒ»ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰å…¥åŠ›ã§éŸ³ãŒé³´ã‚Šã¾ã™ã€‚
        </div>
    </div>

    <div id="status">Waiting for input...</div>
    <div id="canvas-container"></div>

    <!-- Three.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        /**
         * GLOBAL CONFIGURATION
         */
        const CONFIG = {
            fftSize: 128,          // Audio Analysis resolution (must be power of 2)
            gridRows: 50,          // Depth of history
            gridCols: 32,          // Number of frequency bars
            barWidth: 0.8,
            barSpacing: 1.2,
            rowSpacing: 1.2,
            camSpeed: 0.05
        };

        let audioContext, analyser, dataArray, source;
        let isAudioActive = false;
        
        // Visuals
        let scene, camera, renderer;
        let instancedMesh;
        let dummy = new THREE.Object3D();
        let gridData = []; // 2D array storing amplitude history [row][col]

        // Synth
        let mouseOsc, mouseGain;
        
        /**
         * INITIALIZATION & UI
         */
        const overlay = document.getElementById('overlay');
        const statusDiv = document.getElementById('status');
        
        document.getElementById('btn-mic').addEventListener('click', () => startApp('mic'));
        document.getElementById('btn-sys').addEventListener('click', () => startApp('sys'));

        async function startApp(mode) {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = CONFIG.fftSize;
                const bufferLength = analyser.frequencyBinCount;
                dataArray = new Uint8Array(bufferLength);

                let stream;
                if (mode === 'mic') {
                    stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    statusDiv.innerText = "Mode: Microphone Input";
                } else {
                    // System audio capture often requires 'getDisplayMedia' with video
                    // User must check "Share Audio"
                    stream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: true });
                    statusDiv.innerText = "Mode: System Audio";
                }

                source = audioContext.createMediaStreamSource(stream);
                source.connect(analyser);
                // For system audio, we might need to connect to destination to hear it too, 
                // but usually the browser handles the loopback or mutes it to prevent echo.
                // In this case, we just visualize it. 
                
                if (mode === 'sys') {
                     // Creating a gain node to mute the output to speakers to prevent feedback loop 
                     // if the user selected microphone by mistake, but for system audio we usually want to monitor.
                     // Here we just analyze.
                }

                // Initialize Synth
                initSynth();

                // Initialize Visuals
                initThreeJS();
                
                // Hide UI
                overlay.classList.add('hidden');
                isAudioActive = true;
                
                animate();

            } catch (err) {
                console.error(err);
                alert("ã‚¨ãƒ©ãƒ¼: éŸ³å£°ãƒ‡ãƒã‚¤ã‚¹ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ãŒæ‹’å¦ã•ã‚ŒãŸã‹ã€ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚\n" + err.message);
            }
        }

        /**
         * THREE.JS VISUALIZATION
         */
        function initThreeJS() {
            const container = document.getElementById('canvas-container');
            
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f2f5);
            // Add Fog for depth effect (fades into background color)
            scene.fog = new THREE.Fog(0xf0f2f5, 10, 70);

            // Camera
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 15, 25);
            camera.lookAt(0, 0, -20);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            container.appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(10, 20, 10);
            dirLight.castShadow = true;
            scene.add(dirLight);

            // Initialize Grid Data
            // We only use the first 'gridCols' bins from the FFT
            for (let r = 0; r < CONFIG.gridRows; r++) {
                let row = [];
                for (let c = 0; c < CONFIG.gridCols; c++) {
                    row.push(0);
                }
                gridData.push(row);
            }

            // Create Instanced Mesh
            // Total instances = rows * cols
            const geometry = new THREE.BoxGeometry(CONFIG.barWidth, 1, CONFIG.barWidth);
            // Slightly chamfered box looks nicer, but BoxGeometry is lighter.
            
            const material = new THREE.MeshPhysicalMaterial({
                color: 0xffffff,
                metalness: 0.1,
                roughness: 0.2,
                clearcoat: 1.0,
                clearcoatRoughness: 0.1
            });

            const count = CONFIG.gridRows * CONFIG.gridCols;
            instancedMesh = new THREE.InstancedMesh(geometry, material, count);
            instancedMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
            instancedMesh.castShadow = true;
            instancedMesh.receiveShadow = true;
            scene.add(instancedMesh);

            window.addEventListener('resize', onWindowResize, false);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        /**
         * MAIN ANIMATION LOOP
         */
        function animate() {
            requestAnimationFrame(animate);

            if (!isAudioActive) return;

            // 1. Get Audio Data
            analyser.getByteFrequencyData(dataArray);

            // 2. Update Grid Data (Shift rows back)
            // Remove last row, add new row at start
            gridData.pop();
            
            let newRow = [];
            // Pick frequencies distributed across the range
            // We skip low frequencies (index 0-2) often contain DC offset or rumble
            const step = Math.floor((dataArray.length / 2) / CONFIG.gridCols); 
            
            for (let i = 0; i < CONFIG.gridCols; i++) {
                // Determine value
                const val = dataArray[i * step + 2] || 0;
                newRow.push(val);
            }
            gridData.unshift(newRow);

            // 3. Update Instanced Mesh
            let i = 0;
            const centerOffset = (CONFIG.gridCols * CONFIG.barSpacing) / 2;
            const time = Date.now() * 0.001;

            for (let r = 0; r < CONFIG.gridRows; r++) {
                for (let c = 0; c < CONFIG.gridCols; c++) {
                    const val = gridData[r][c];
                    const normVal = val / 255.0; // 0.0 to 1.0

                    // Position
                    // x centered, z going negative (into screen)
                    const x = (c * CONFIG.barSpacing) - centerOffset;
                    const z = -(r * CONFIG.rowSpacing);
                    
                    // Height based on audio
                    const scaleY = Math.max(0.1, normVal * 8); 
                    const y = scaleY / 2; // Sit on floor

                    dummy.position.set(x, y, z);
                    dummy.scale.set(1, scaleY, 1);
                    dummy.updateMatrix();
                    instancedMesh.setMatrixAt(i, dummy.matrix);

                    // Color - Aesthetic Logic
                    // Hue varies by X (freq) and Time
                    // Lightness varies by Amplitude (Active = Bright)
                    const hue = (c / CONFIG.gridCols) * 0.5 + (time * 0.05); 
                    const saturation = 0.8;
                    const lightness = 0.3 + (normVal * 0.4);
                    
                    const color = new THREE.Color().setHSL(hue % 1, saturation, lightness);
                    instancedMesh.setColorAt(i, color);

                    i++;
                }
            }
            
            instancedMesh.instanceMatrix.needsUpdate = true;
            if (instancedMesh.instanceColor) instancedMesh.instanceColor.needsUpdate = true;

            // 4. Camera & Scene Movement (Dynamic Feel)
            // Gentle sway
            camera.position.x = Math.sin(time * 0.3) * 5;
            camera.lookAt(0, 0, -20);

            // React to Bass (low freq) for global shake/pulse
            const bass = gridData[0][Math.floor(CONFIG.gridCols/2)];
            if(bass > 180) {
                 camera.position.y = 15 + (bass - 180) * 0.01;
            }

            renderer.render(scene, camera);
        }

        /**
         * INTERACTIVE SOUND GENERATION
         */
        function initSynth() {
            // Mouse Theremin
            mouseOsc = audioContext.createOscillator();
            mouseGain = audioContext.createGain();
            
            mouseOsc.type = 'sine';
            mouseOsc.frequency.value = 440;
            mouseOsc.start();
            
            mouseGain.gain.value = 0; // Start silent
            
            // Chain
            mouseOsc.connect(mouseGain);
            mouseGain.connect(audioContext.destination);
            // Also connect synth to analyser so we can see what we play!
            mouseGain.connect(analyser);

            setupInteraction();
        }

        function setupInteraction() {
            // Mouse Move (Theremin)
            document.addEventListener('mousemove', (e) => {
                if (!isAudioActive) return;
                
                const x = e.clientX / window.innerWidth;
                const y = e.clientY / window.innerHeight;

                // Frequency mapped to X (200Hz - 800Hz)
                const freq = 200 + (x * 800);
                mouseOsc.frequency.setTargetAtTime(freq, audioContext.currentTime, 0.1);

                // Volume mapped to Y (Lower screen = louder, somewhat)
                // Actually let's make it volume based on movement speed or just keep it low background
                // Let's toggle volume based on if mouse is moving? 
                // Requirement: "Generate stylish sound". Let's use simple XY pad style.
                // Volume is higher at the bottom.
                const vol = Math.max(0, (1 - y) * 0.1); 
                mouseGain.gain.setTargetAtTime(vol, audioContext.currentTime, 0.1);
            });

            // Click (Bell/Pluck)
            document.addEventListener('mousedown', () => {
                if (!isAudioActive) return;
                playTone('triangle', 600 + Math.random() * 400, 0.5, 0.8);
                createVisualRipple();
            });

            // Typing (Pentatonic Scale)
            const pentatonic = [261.63, 293.66, 329.63, 392.00, 440.00, 523.25, 587.33, 659.25]; // C D E G A C D E
            document.addEventListener('keydown', (e) => {
                if (!isAudioActive) return;
                
                // Map char code to note
                const noteIndex = e.code.length % pentatonic.length;
                // Add octave variation
                const freq = pentatonic[noteIndex] * (Math.random() > 0.8 ? 2 : 1);
                
                playTone('sine', freq, 0.2, 0.3);
            });
        }

        function playTone(type, freq, duration, maxVol) {
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();

            osc.type = type;
            osc.frequency.setValueAtTime(freq, audioContext.currentTime);

            gain.gain.setValueAtTime(0, audioContext.currentTime);
            gain.gain.linearRampToValueAtTime(maxVol, audioContext.currentTime + 0.05);
            gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);

            osc.connect(gain);
            gain.connect(audioContext.destination);
            gain.connect(analyser); // Visualize typing

            osc.start();
            osc.stop(audioContext.currentTime + duration);
        }

        // Simple visual effect for click (change background briefly)
        function createVisualRipple() {
            scene.background.setHex(0xffeef5); // slight pink flash
            setTimeout(() => {
                scene.background.setHex(0xf0f2f5);
            }, 100);
        }

    </script>
</body>
</html>
